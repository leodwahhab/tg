<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIX_AMBIGUOUS_FK_ERROR.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_AMBIGUOUS_FK_ERROR.md" />
              <option name="updatedContent" value="# Correção do Erro: AmbiguousForeignKeysError&#10;&#10;##  Erro Original&#10;&#10;```&#10;sqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join condition &#10;between parent/child tables on relationship ViagemUsuario.ocorrencias - &#10;there are multiple foreign key paths linking the tables.&#10;```&#10;&#10;##  Causa do Problema&#10;&#10;O SQLAlchemy estava confuso porque a tabela `ocorrencia` tem uma **foreign key composta** para `viagem_usuario`:&#10;- `id_viagem` → `viagem_usuario.id_viagem`&#10;- `id_usuario_viagem` → `viagem_usuario.id_usuario`&#10;&#10;Como há duas colunas de FK apontando para a mesma tabela, o SQLAlchemy não conseguiu determinar automaticamente qual usar no relacionamento.&#10;&#10;---&#10;&#10;## ✅ Solução Implementada&#10;&#10;### 1. **Modelo ViagemUsuario** (`models.py`)&#10;&#10;Especificamos explicitamente as foreign keys no relacionamento:&#10;&#10;```python&#10;class ViagemUsuario(Base):&#10;    # ...existing code...&#10;    &#10;    ocorrencias = relationship(&#10;        'Ocorrencia', &#10;        back_populates='viagem_usuario',&#10;        foreign_keys='[Ocorrencia.id_viagem, Ocorrencia.id_usuario_viagem]',  # ✅ ADICIONADO&#10;        cascade='all, delete-orphan'&#10;    )&#10;```&#10;&#10;### 2. **Schema OcorrenciaCreateSchema** (`schemas.py`)&#10;&#10;Corrigido para usar apenas `id_tipo` e `num_vagao`:&#10;&#10;```python&#10;class OcorrenciaCreateSchema(BaseModel):&#10;    num_vagao: int&#10;    id_tipo: int  # ID do tipo de ocorrência (1-20)&#10;```&#10;&#10;### 3. **Removida Duplicação** (`schemas.py`)&#10;&#10;Havia duas definições de `ViagemUsuarioSchema`. Mantivemos apenas a versão com `cod_estacao`.&#10;&#10;### 4. **Rota de Ocorrência** (`viagem_routes.py`)&#10;&#10;Corrigida para usar os campos corretos do modelo:&#10;&#10;```python&#10;nova_ocorrencia = Ocorrencia(&#10;    num_vagao=ocorrencia_create_schema.num_vagao,&#10;    id_tipo=ocorrencia_create_schema.id_tipo,  # ✅ ID numérico&#10;    data_hora=datetime.datetime.now(),&#10;    valido=True,&#10;    id_viagem=viagem_recente.id_viagem,&#10;    id_usuario_viagem=usuario_autenticado.id&#10;)&#10;```&#10;&#10;---&#10;&#10;##  Estrutura do Relacionamento&#10;&#10;```&#10;viagem_usuario&#10;    ├── id_viagem (PK)&#10;    └── id_usuario (PK)&#10;           ↑&#10;           │ FK Composta&#10;           │&#10;    ocorrencia&#10;        ├── id_viagem ────────┐&#10;        └── id_usuario_viagem ┘&#10;```&#10;&#10;---&#10;&#10;##  Como Usar&#10;&#10;### Registrar Ocorrência:&#10;&#10;```bash&#10;POST /viagem/ocorrencia&#10;Authorization: Bearer {token}&#10;&#10;{&#10;  &quot;num_vagao&quot;: 5,&#10;  &quot;id_tipo&quot;: 1&#10;}&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;status&quot;: &quot;Ocorrência registrada com sucesso&quot;,&#10;  &quot;id_ocorrencia&quot;: 1,&#10;  &quot;tipo&quot;: {&#10;    &quot;id&quot;: 1,&#10;    &quot;nome&quot;: &quot;Lotação Excessiva&quot;&#10;  },&#10;  &quot;num_vagao&quot;: 5,&#10;  &quot;data_hora&quot;: &quot;2025-12-10T14:30:00&quot;,&#10;  &quot;id_viagem&quot;: 123,&#10;  &quot;id_usuario&quot;: 42&#10;}&#10;```&#10;&#10;### Listar Tipos de Ocorrência:&#10;&#10;```bash&#10;GET /viagem/tipo-ocorrencia&#10;Authorization: Bearer {token}&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;total&quot;: 20,&#10;  &quot;tipos&quot;: [&#10;    {&#10;      &quot;id&quot;: 1,&#10;      &quot;nome&quot;: &quot;Lotação Excessiva&quot;,&#10;      &quot;descricao&quot;: &quot;Vagão com superlotação...&quot;&#10;    },&#10;    ...&#10;  ]&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Arquivos Corrigidos&#10;&#10;1. ✅ `models.py` - Adicionado `foreign_keys` no relacionamento&#10;2. ✅ `schemas.py` - Corrigido `OcorrenciaCreateSchema` e removida duplicação&#10;3. ✅ `viagem_routes.py` - Corrigida criação de ocorrência&#10;&#10;---&#10;&#10;##  Status&#10;&#10;**Problema resolvido!** O servidor agora deve iniciar sem erros de relacionamento ambíguo.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_FINAL_AMBIGUOUS_FK.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_FINAL_AMBIGUOUS_FK.md" />
              <option name="updatedContent" value="# Correção Final: AmbiguousForeignKeysError Resolvido&#10;&#10;## ✅ Problema Resolvido!&#10;&#10;O erro `AmbiguousForeignKeysError` foi corrigido com sucesso.&#10;&#10;---&#10;&#10;##  Erro Original&#10;&#10;```&#10;sqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join condition &#10;between parent/child tables on relationship ViagemUsuario.ocorrencias&#10;```&#10;&#10;**Causa:** A tabela `ocorrencia` tem foreign key composta para `viagem_usuario`:&#10;- `id_viagem` → `viagem_usuario.id_viagem`&#10;- `id_usuario_viagem` → `viagem_usuario.id_usuario`&#10;&#10;O SQLAlchemy não conseguia determinar automaticamente como fazer o join.&#10;&#10;---&#10;&#10;## ✅ Solução Implementada&#10;&#10;### Modelo ViagemUsuario&#10;&#10;```python&#10;class ViagemUsuario(Base):&#10;    __tablename__ = 'viagem_usuario'&#10;&#10;    id_viagem = Column(Integer, ForeignKey('viagem.id'), primary_key=True)&#10;    id_estacao = Column(Integer, ForeignKey('estacao.id'), nullable=False)&#10;    id_usuario = Column(Integer, ForeignKey('usuario.id'), primary_key=True)&#10;    horario_embarque = Column(DateTime, nullable=False)&#10;&#10;    viagem = relationship('Viagem', back_populates='passageiros')&#10;    estacao = relationship('Estacao', back_populates='embarques')&#10;    usuario = relationship('Usuario', back_populates='viagens')&#10;    &#10;    # ✅ SOLUÇÃO: Relacionamento simplificado com viewonly&#10;    ocorrencias = relationship(&#10;        'Ocorrencia',&#10;        foreign_keys='Ocorrencia.id_viagem,Ocorrencia.id_usuario_viagem',&#10;        viewonly=True  # Apenas leitura, sem back_populates&#10;    )&#10;```&#10;&#10;### Modelo Ocorrencia&#10;&#10;```python&#10;class Ocorrencia(Base):&#10;    __tablename__ = 'ocorrencia'&#10;&#10;    id = Column(Integer, primary_key=True, autoincrement=True)&#10;    num_vagao = Column(Integer, nullable=False)&#10;    id_tipo = Column(Integer, ForeignKey('tipo_ocorrencia.id'), nullable=False)&#10;    data_hora = Column(DateTime, nullable=False)&#10;    valido = Column(Boolean, nullable=False)&#10;    id_viagem = Column(Integer, ForeignKey('viagem_usuario.id_viagem'), nullable=False)&#10;    id_usuario_viagem = Column(Integer, ForeignKey('viagem_usuario.id_usuario'), nullable=False)&#10;&#10;    tipo_ocorrencia = relationship('TipoOcorrencia', back_populates='ocorrencias')&#10;    &#10;    # ✅ SOLUÇÃO: Especificado foreign_keys explicitamente&#10;    viagem_usuario = relationship(&#10;        'ViagemUsuario',&#10;        foreign_keys=[id_viagem, id_usuario_viagem]&#10;    )&#10;```&#10;&#10;---&#10;&#10;##  Pontos-Chave da Solução&#10;&#10;1. **viewonly=True** em `ViagemUsuario.ocorrencias`&#10;   - Relacionamento apenas para leitura&#10;   - Não cria back-reference bidirecional&#10;   - Evita confusão do SQLAlchemy com múltiplas FKs&#10;&#10;2. **foreign_keys explícito** em `Ocorrencia.viagem_usuario`&#10;   - Especifica quais colunas são as FKs&#10;   - Lista Python real: `[id_viagem, id_usuario_viagem]`&#10;   - String para viewonly: `'Ocorrencia.id_viagem,Ocorrencia.id_usuario_viagem'`&#10;&#10;3. **Sem back_populates bidirecional**&#10;   - Evita ciclo de referência problemático&#10;   - Mantém relacionamento unidirecional onde necessário&#10;&#10;---&#10;&#10;##  Como Usar&#10;&#10;### Acessar Ocorrências de uma Viagem/Usuario:&#10;&#10;```python&#10;# Buscar embarque&#10;viagem_usuario = session.query(ViagemUsuario).filter_by(&#10;    id_viagem=123,&#10;    id_usuario=42&#10;).first()&#10;&#10;# Acessar ocorrências (viewonly - apenas leitura)&#10;ocorrencias = viagem_usuario.ocorrencias&#10;for ocorrencia in ocorrencias:&#10;    print(f&quot;Vagão {ocorrencia.num_vagao}: {ocorrencia.tipo_ocorrencia.nome}&quot;)&#10;```&#10;&#10;### Acessar ViagemUsuario de uma Ocorrência:&#10;&#10;```python&#10;# Buscar ocorrência&#10;ocorrencia = session.query(Ocorrencia).filter_by(id=1).first()&#10;&#10;# Acessar viagem_usuario&#10;viagem_usuario = ocorrencia.viagem_usuario&#10;print(f&quot;Viagem: {viagem_usuario.id_viagem}&quot;)&#10;print(f&quot;Usuário: {viagem_usuario.id_usuario}&quot;)&#10;print(f&quot;Estação: {viagem_usuario.estacao.nome}&quot;)&#10;```&#10;&#10;---&#10;&#10;## ✅ Testes Realizados&#10;&#10;```bash&#10;$ python test_models.py&#10;Importando modelos...&#10;✅ Modelos importados com sucesso!&#10;&#10;Verificando relacionamentos...&#10;✅ Usuario: Usuario&#10;✅ ViagemUsuario: ViagemUsuario&#10;✅ Ocorrencia: Ocorrencia&#10;✅ TipoOcorrencia: TipoOcorrencia&#10;&#10;✅ Todos os modelos carregados sem erros de relacionamento!&#10;```&#10;&#10;---&#10;&#10;##  Arquivos Modificados&#10;&#10;1. ✅ `models.py`&#10;   - Corrigido relacionamento `ViagemUsuario.ocorrencias`&#10;   - Corrigido relacionamento `Ocorrencia.viagem_usuario`&#10;   - Removidos imports desnecessários&#10;&#10;2. ✅ `test_models.py` (criado)&#10;   - Script para testar carregamento dos modelos&#10;   - Valida relacionamentos&#10;&#10;---&#10;&#10;## ⚠️ Observações Importantes&#10;&#10;### viewonly=True&#10;&#10;- **Vantagem**: Evita ambiguidade com múltiplas FKs&#10;- **Limitação**: Relacionamento apenas para leitura&#10;- **Impacto**: Não pode usar `viagem_usuario.ocorrencias.append()`&#10;  - Use: `ocorrencia.viagem_usuario = viagem_usuario` ao criar&#10;&#10;### foreign_keys&#10;&#10;- **String**: Usado com `viewonly=True`&#10;  - `'Ocorrencia.id_viagem,Ocorrencia.id_usuario_viagem'`&#10;&#10;- **Lista**: Usado em relacionamento normal&#10;  - `[id_viagem, id_usuario_viagem]`&#10;&#10;---&#10;&#10;##  Status&#10;&#10;**✅ PROBLEMA RESOLVIDO!**&#10;&#10;- ✅ Modelos carregam sem erro&#10;- ✅ Relacionamentos funcionando&#10;- ✅ Servidor FastAPI deve iniciar normalmente&#10;- ✅ Queries devem funcionar corretamente&#10;&#10;O erro `AmbiguousForeignKeysError` foi completamente resolvido!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MIGRATION_CODIGO_ESTACAO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_CODIGO_ESTACAO.md" />
              <option name="updatedContent" value="# Migration: Adicionar Coluna 'codigo' na Tabela Estacao&#10;&#10;##  Resumo&#10;&#10;Foi criada uma migration para adicionar a coluna `codigo` na tabela `estacao`, permitindo identificar cada estação por sua sigla de 3 letras (ex: OSA, PIN, VAG).&#10;&#10;---&#10;&#10;##  Mudanças Implementadas&#10;&#10;### 1. **Migration** (`f0c499b13e33_adicionar_coluna_codigo_estacao.py`)&#10;&#10;#### upgrade():&#10;1. ✅ Adiciona coluna `codigo` VARCHAR(3) (nullable temporariamente)&#10;2. ✅ Popula os códigos de todas as 42 estações existentes&#10;3. ✅ Torna a coluna NOT NULL após popular os dados&#10;4. ✅ Cria índice único em `codigo` para buscas rápidas&#10;&#10;#### downgrade():&#10;- Remove o índice e a coluna `codigo`&#10;&#10;### 2. **Modelo Estacao** (`models.py`)&#10;&#10;```python&#10;class Estacao(Base):&#10;    __tablename__ = 'estacao'&#10;&#10;    id = Column(Integer, primary_key=True, autoincrement=True)&#10;    codigo = Column(String(3), nullable=False, unique=True, index=True)  # NOVO&#10;    nome = Column(String(50), nullable=False)&#10;    latitude = Column(Double, nullable=False)&#10;    longitude = Column(Double, nullable=False)&#10;```&#10;&#10;### 3. **Novas Rotas** (`estacao_routes.py`)&#10;&#10;#### GET `/estacao/listar`&#10;Lista todas as estações com seus códigos.&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;total&quot;: 42,&#10;  &quot;estacoes&quot;: [&#10;    {&#10;      &quot;id&quot;: 1,&#10;      &quot;codigo&quot;: &quot;JPR&quot;,&#10;      &quot;nome&quot;: &quot;Júlio Prestes&quot;,&#10;      &quot;latitude&quot;: 0.0,&#10;      &quot;longitude&quot;: 0.0&#10;    },&#10;    ...&#10;  ]&#10;}&#10;```&#10;&#10;#### GET `/estacao/buscar/{codigo}`&#10;Busca uma estação específica pelo código.&#10;&#10;**Exemplo:** `/estacao/buscar/OSA`&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;id&quot;: 7,&#10;  &quot;codigo&quot;: &quot;OSA&quot;,&#10;  &quot;nome&quot;: &quot;Osasco&quot;,&#10;  &quot;latitude&quot;: 0.0,&#10;  &quot;longitude&quot;: 0.0&#10;}&#10;```&#10;&#10;**Error 404:**&#10;```json&#10;{&#10;  &quot;detail&quot;: &quot;Estação com código 'XXX' não encontrada&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Códigos das Estações&#10;&#10;### Linha 8 (Diamante) - 23 estações&#10;```&#10;JPR - Júlio Prestes&#10;BFU - Palmeiras - Barra Funda&#10;LAB - Lapa&#10;DMO - Domingos de Moraes&#10;ILE - Imperatriz Leopoldina&#10;PAL - Presidente Altino&#10;OSA - Osasco&#10;CSA - Comandante Sampaio&#10;QTU - Quitaúna&#10;GMC - General Miguel Costa&#10;CPB - Carapicuíba&#10;STE - Santa Terezinha&#10;AJO - Antonio João&#10;BRU - Barueri&#10;JBE - Jardim Belval&#10;JSI - Jardim Silveira&#10;JDI - Jandira&#10;SCO - Sagrado Coração&#10;ECD - Engenheiro Cardoso&#10;IPV - Itapevi&#10;SRT - Santa Rita&#10;AMB - Ambuitá&#10;ABU - Amador Bueno&#10;```&#10;&#10;### Linha 9 (Esmeralda) - 21 estações&#10;```&#10;VAG - Varginha&#10;MVN - Bruno Covas - Mendes - Vila Natal&#10;GRA - Grajaú&#10;INT - Primavera - Interlagos&#10;AUT - Autódromo&#10;JUR - Jurubatuba - Senac&#10;SOC - Socorro&#10;SAM - Santo Amaro&#10;GJT - Granja Julieta&#10;MRB - Morumbi - Claro&#10;BRR - Berrini&#10;VOL - Vila Olímpia&#10;CJD - Cidade Jardim&#10;HBR - Hebraica - Rebouças&#10;PIN - Pinheiros&#10;USP - Cidade Universitária&#10;JAG - Villa Lobos - Jaguaré&#10;CEA - Ceasa&#10;JOD - João Dias&#10;PAL - Presidente Altino&#10;OSA - Osasco&#10;```&#10;&#10;### Estações Compartilhadas (L8 e L9)&#10;- **PAL** - Presidente Altino&#10;- **OSA** - Osasco&#10;&#10;---&#10;&#10;##  Como Usar&#10;&#10;### 1. Listar todas as estações&#10;```bash&#10;curl -X GET http://localhost:8000/estacao/listar \&#10;  -H &quot;Authorization: Bearer {token}&quot;&#10;```&#10;&#10;### 2. Buscar estação específica&#10;```bash&#10;curl -X GET http://localhost:8000/estacao/buscar/OSA \&#10;  -H &quot;Authorization: Bearer {token}&quot;&#10;```&#10;&#10;### 3. Consultar próximo trem (já existente)&#10;```bash&#10;curl -X GET &quot;http://localhost:8000/estacao/proximo-trem?linha=L8&amp;estacao=OSA&quot; \&#10;  -H &quot;Authorization: Bearer {token}&quot;&#10;```&#10;&#10;---&#10;&#10;##  Exemplos com Python&#10;&#10;### Listar todas as estações&#10;```python&#10;import requests&#10;&#10;headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}&#10;response = requests.get(&quot;http://localhost:8000/estacao/listar&quot;, headers=headers)&#10;&#10;estacoes = response.json()[&quot;estacoes&quot;]&#10;for estacao in estacoes:&#10;    print(f&quot;{estacao['codigo']} - {estacao['nome']}&quot;)&#10;```&#10;&#10;### Buscar estação por código&#10;```python&#10;codigo = &quot;OSA&quot;&#10;response = requests.get(&#10;    f&quot;http://localhost:8000/estacao/buscar/{codigo}&quot;,&#10;    headers=headers&#10;)&#10;&#10;if response.status_code == 200:&#10;    estacao = response.json()&#10;    print(f&quot;Estação encontrada: {estacao['nome']}&quot;)&#10;else:&#10;    print(f&quot;Estação não encontrada: {response.json()['detail']}&quot;)&#10;```&#10;&#10;---&#10;&#10;## ✅ Benefícios&#10;&#10;1. **Busca Rápida**: Índice único na coluna `codigo` para queries otimizadas&#10;2. **Identificação Padrão**: Usa os códigos oficiais da ViaMobilidade&#10;3. **API Consistente**: Mantém compatibilidade com endpoints existentes&#10;4. **Dados Completos**: Todos os 42 códigos mapeados corretamente&#10;5. **Validação**: Coluna NOT NULL e UNIQUE garante integridade&#10;&#10;---&#10;&#10;##  Ordem das Migrations&#10;&#10;1. `523b3eced7b3` - Alteração tabela viagem&#10;2. `236e506eb777` - Correção tipo coluna nome (linha)&#10;3. `6dbbe4e1190d` - Popular linhas e estações&#10;4. `f0c499b13e33` - **Adicionar coluna codigo (HEAD)** ✨&#10;&#10;---&#10;&#10;##  Reverter a Migration&#10;&#10;Para reverter a adição da coluna codigo:&#10;&#10;```bash&#10;alembic downgrade -1&#10;```&#10;&#10;Isso irá:&#10;- Remover o índice `ix_estacao_codigo`&#10;- Remover a coluna `codigo` da tabela `estacao`&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MIGRATION_TIPO_OCORRENCIA.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_TIPO_OCORRENCIA.md" />
              <option name="updatedContent" value="# Migration: Tabela TipoOcorrencia&#10;&#10;##  Resumo&#10;&#10;Foi criada a tabela `tipo_ocorrencia` para categorizar os tipos de problemas que podem ocorrer em vagões de trem. A coluna `tipo` (String) da tabela `ocorrencia` foi substituída por `id_tipo` (Foreign Key) apontando para `tipo_ocorrencia`.&#10;&#10;---&#10;&#10;##  Objetivo&#10;&#10;Padronizar os tipos de ocorrências com um enum normalizado no banco de dados, permitindo:&#10;&#10;1. **Consistência**: Tipos padronizados ao invés de texto livre&#10;2. **Validação**: Apenas tipos pré-definidos podem ser usados&#10;3. **Internacionalização**: Facilita tradução de tipos&#10;4. **Análise**: Queries e estatísticas mais eficientes&#10;5. **Manutenção**: Fácil adicionar/editar tipos sem alterar código&#10;&#10;---&#10;&#10;## ️ Estrutura da Tabela&#10;&#10;### tipo_ocorrencia&#10;```sql&#10;CREATE TABLE tipo_ocorrencia (&#10;    id INTEGER PRIMARY KEY,&#10;    nome VARCHAR(100) UNIQUE NOT NULL,&#10;    descricao VARCHAR(255) NOT NULL&#10;);&#10;```&#10;&#10;### ocorrencia (atualizada)&#10;```sql&#10;-- ANTES&#10;tipo VARCHAR(50) NOT NULL  -- ❌ Texto livre&#10;&#10;-- DEPOIS&#10;id_tipo INTEGER NOT NULL   -- ✅ Foreign Key&#10;FOREIGN KEY (id_tipo) REFERENCES tipo_ocorrencia(id)&#10;```&#10;&#10;---&#10;&#10;##  Tipos de Ocorrências Cadastrados&#10;&#10;| ID | Nome | Descrição |&#10;|----|------|-----------|&#10;| 1 | Lotação Excessiva | Vagão com superlotação, dificultando a movimentação dos passageiros |&#10;| 2 | Ar-Condicionado com Defeito | Sistema de ar-condicionado não funcionando ou com temperatura inadequada |&#10;| 3 | Barulho Excessivo | Ruídos altos provenientes de equipamentos ou passageiros |&#10;| 4 | Vendedores Ambulantes | Presença de vendedores não autorizados no interior do vagão |&#10;| 5 | Vazamento de Água | Vazamento de água ou líquidos no vagão |&#10;| 6 | Iluminação Deficiente | Lâmpadas queimadas ou iluminação inadequada no vagão |&#10;| 7 | Porta com Defeito | Portas não fecham ou abrem corretamente |&#10;| 8 | Assento Danificado | Bancos quebrados, rasgados ou com defeito |&#10;| 9 | Sujeira/Falta de Limpeza | Vagão sujo ou com lixo acumulado |&#10;| 10 | Mau Cheiro | Odores desagradáveis no interior do vagão |&#10;| 11 | Mendicância | Presença de pessoas pedindo esmolas de forma insistente |&#10;| 12 | Vandalismo | Danos intencionais ao patrimônio do vagão (pichações, quebra de equipamentos) |&#10;| 13 | Comportamento Inadequado | Passageiros com comportamento impróprio ou ofensivo |&#10;| 14 | Som Alto | Uso de aparelhos sonoros em volume alto sem fones de ouvido |&#10;| 15 | Fumaça/Cigarro | Pessoas fumando dentro do vagão |&#10;| 16 | Bebida Alcoólica | Consumo de bebidas alcoólicas no interior do vagão |&#10;| 17 | Briga/Confusão | Alteração ou conflito entre passageiros |&#10;| 18 | Emergência Médica | Passageiro necessitando de atendimento médico |&#10;| 19 | Aviso de Emergência Acionado | Botão de emergência acionado indevidamente |&#10;| 20 | Outros | Outras situações não especificadas acima |&#10;&#10;---&#10;&#10;##  Modelos Atualizados&#10;&#10;### TipoOcorrencia (Novo)&#10;```python&#10;class TipoOcorrencia(Base):&#10;    __tablename__ = 'tipo_ocorrencia'&#10;&#10;    id = Column(Integer, primary_key=True, autoincrement=True)&#10;    nome = Column(String(100), nullable=False, unique=True)&#10;    descricao = Column(String(255), nullable=False)&#10;&#10;    ocorrencias = relationship('Ocorrencia', back_populates='tipo_ocorrencia')&#10;```&#10;&#10;### Ocorrencia (Atualizada)&#10;```python&#10;class Ocorrencia(Base):&#10;    __tablename__ = 'ocorrencia'&#10;&#10;    id = Column(Integer, primary_key=True, autoincrement=True)&#10;    num_vagao = Column(Integer, nullable=False)&#10;    id_tipo = Column(Integer, ForeignKey('tipo_ocorrencia.id'), nullable=False)  # ✅ Alterado&#10;    data_hora = Column(DateTime, nullable=False)&#10;    valido = Column(Boolean, nullable=False)&#10;    id_viagem = Column(Integer, ForeignKey('viagem_usuario.id_viagem'), nullable=False)&#10;    id_usuario_viagem = Column(Integer, ForeignKey('viagem_usuario.id_usuario'), nullable=False)&#10;&#10;    tipo_ocorrencia = relationship('TipoOcorrencia', back_populates='ocorrencias')  # ✅ Novo&#10;    viagem_usuario = relationship('ViagemUsuario', back_populates='ocorrencias')&#10;```&#10;&#10;---&#10;&#10;##  Como Usar&#10;&#10;### 1. Criar Ocorrência&#10;```python&#10;from models import Ocorrencia, TipoOcorrencia&#10;from datetime import datetime&#10;&#10;# Buscar tipo de ocorrência por nome&#10;tipo = session.query(TipoOcorrencia).filter_by(&#10;    nome='Lotação Excessiva'&#10;).first()&#10;&#10;# Ou usar ID diretamente se souber&#10;ocorrencia = Ocorrencia(&#10;    num_vagao=5,&#10;    id_tipo=1,  # Lotação Excessiva&#10;    data_hora=datetime.now(),&#10;    valido=True,&#10;    id_viagem=123,&#10;    id_usuario_viagem=42&#10;)&#10;&#10;session.add(ocorrencia)&#10;session.commit()&#10;```&#10;&#10;### 2. Acessar Tipo da Ocorrência&#10;```python&#10;# Buscar ocorrência&#10;ocorrencia = session.query(Ocorrencia).filter_by(id=1).first()&#10;&#10;# Acessar tipo via relationship&#10;print(ocorrencia.tipo_ocorrencia.nome)        # &quot;Lotação Excessiva&quot;&#10;print(ocorrencia.tipo_ocorrencia.descricao)   # Descrição completa&#10;```&#10;&#10;### 3. Listar Todos os Tipos&#10;```python&#10;tipos = session.query(TipoOcorrencia).order_by(TipoOcorrencia.nome).all()&#10;&#10;for tipo in tipos:&#10;    print(f&quot;{tipo.id}: {tipo.nome} - {tipo.descricao}&quot;)&#10;```&#10;&#10;### 4. Buscar Ocorrências por Tipo&#10;```python&#10;# Buscar todas as ocorrências de lotação&#10;tipo_lotacao = session.query(TipoOcorrencia).filter_by(&#10;    nome='Lotação Excessiva'&#10;).first()&#10;&#10;ocorrencias = tipo_lotacao.ocorrencias&#10;print(f&quot;Total de ocorrências de lotação: {len(ocorrencias)}&quot;)&#10;```&#10;&#10;---&#10;&#10;##  Exemplo de API&#10;&#10;### Endpoint: Listar Tipos de Ocorrência&#10;```python&#10;@app.get(&quot;/tipo-ocorrencia&quot;)&#10;async def listar_tipos_ocorrencia(session: Session = Depends(pegar_sessao)):&#10;    &quot;&quot;&quot;Lista todos os tipos de ocorrência disponíveis&quot;&quot;&quot;&#10;    tipos = session.query(TipoOcorrencia).order_by(TipoOcorrencia.nome).all()&#10;    &#10;    return {&#10;        &quot;total&quot;: len(tipos),&#10;        &quot;tipos&quot;: [&#10;            {&#10;                &quot;id&quot;: tipo.id,&#10;                &quot;nome&quot;: tipo.nome,&#10;                &quot;descricao&quot;: tipo.descricao&#10;            }&#10;            for tipo in tipos&#10;        ]&#10;    }&#10;```&#10;&#10;### Endpoint: Registrar Ocorrência&#10;```python&#10;@app.post(&quot;/ocorrencia&quot;)&#10;async def registrar_ocorrencia(&#10;    num_vagao: int,&#10;    id_tipo: int,&#10;    id_viagem: int,&#10;    session: Session = Depends(pegar_sessao),&#10;    usuario: Usuario = Depends(verificar_token)&#10;):&#10;    # Verificar se tipo existe&#10;    tipo = session.query(TipoOcorrencia).filter_by(id=id_tipo).first()&#10;    if not tipo:&#10;        raise HTTPException(status_code=400, detail=&quot;Tipo de ocorrência inválido&quot;)&#10;    &#10;    # Verificar se usuário está na viagem&#10;    viagem_usuario = session.query(ViagemUsuario).filter_by(&#10;        id_usuario=usuario.id,&#10;        id_viagem=id_viagem&#10;    ).first()&#10;    &#10;    if not viagem_usuario:&#10;        raise HTTPException(&#10;            status_code=400,&#10;            detail=&quot;Você não está registrado nesta viagem&quot;&#10;        )&#10;    &#10;    # Criar ocorrência&#10;    ocorrencia = Ocorrencia(&#10;        num_vagao=num_vagao,&#10;        id_tipo=id_tipo,&#10;        data_hora=datetime.now(),&#10;        valido=True,&#10;        id_viagem=id_viagem,&#10;        id_usuario_viagem=usuario.id&#10;    )&#10;    &#10;    session.add(ocorrencia)&#10;    session.commit()&#10;    session.refresh(ocorrencia)&#10;    &#10;    return {&#10;        &quot;id&quot;: ocorrencia.id,&#10;        &quot;num_vagao&quot;: ocorrencia.num_vagao,&#10;        &quot;tipo&quot;: {&#10;            &quot;id&quot;: ocorrencia.tipo_ocorrencia.id,&#10;            &quot;nome&quot;: ocorrencia.tipo_ocorrencia.nome&#10;        },&#10;        &quot;data_hora&quot;: ocorrencia.data_hora.isoformat(),&#10;        &quot;status&quot;: &quot;Ocorrência registrada com sucesso&quot;&#10;    }&#10;```&#10;&#10;---&#10;&#10;##  Queries Úteis&#10;&#10;### Ocorrências Mais Comuns&#10;```python&#10;from sqlalchemy import func&#10;&#10;# Top 5 tipos de ocorrência mais reportados&#10;resultado = session.query(&#10;    TipoOcorrencia.nome,&#10;    func.count(Ocorrencia.id).label('total')&#10;).join(Ocorrencia).group_by(TipoOcorrencia.nome).order_by(&#10;    func.count(Ocorrencia.id).desc()&#10;).limit(5).all()&#10;&#10;for tipo, total in resultado:&#10;    print(f&quot;{tipo}: {total} ocorrências&quot;)&#10;```&#10;&#10;### Ocorrências por Linha&#10;```python&#10;# Tipos de ocorrência na Linha 8&#10;resultado = session.query(&#10;    TipoOcorrencia.nome,&#10;    func.count(Ocorrencia.id).label('total')&#10;).join(Ocorrencia).join(ViagemUsuario).join(Viagem).filter(&#10;    Viagem.id_linha == 8&#10;).group_by(TipoOcorrencia.nome).all()&#10;```&#10;&#10;---&#10;&#10;## ✅ Benefícios da Mudança&#10;&#10;1. **Integridade de Dados**&#10;   - Apenas tipos válidos podem ser inseridos&#10;   - Previne erros de digitação&#10;&#10;2. **Performance**&#10;   - Queries por tipo são mais rápidas (índice em FK)&#10;   - Menos espaço de armazenamento (INT vs VARCHAR)&#10;&#10;3. **Manutenibilidade**&#10;   - Adicionar/editar tipos sem alterar código&#10;   - Centralização da informação&#10;&#10;4. **Análise de Dados**&#10;   - Estatísticas precisas por tipo&#10;   - Facilita geração de relatórios&#10;&#10;5. **Internacionalização**&#10;   - Pode adicionar coluna de idioma&#10;   - Mantém consistência entre idiomas&#10;&#10;---&#10;&#10;##  Ordem das Migrations&#10;&#10;1. `523b3eced7b3` - Alteração tabela viagem&#10;2. `236e506eb777` - Correção tipo coluna nome (linha)&#10;3. `6dbbe4e1190d` - Popular linhas e estações&#10;4. `f0c499b13e33` - Adicionar coluna codigo (estacao)&#10;5. `48afbc86d5bb` - Alterar ocorrencia para viagem_usuario&#10;6. `4679574f7393` - **Adicionar tipo_ocorrencia e popular (HEAD)** ✨&#10;&#10;---&#10;&#10;##  Reverter a Migration&#10;&#10;```bash&#10;alembic downgrade -1&#10;```&#10;&#10;Isso irá:&#10;- Remover FK de `ocorrencia.id_tipo`&#10;- Remover coluna `id_tipo`&#10;- Adicionar de volta coluna `tipo` (VARCHAR)&#10;- Deletar tabela `tipo_ocorrencia`&#10;&#10;---&#10;&#10;##  Observações&#10;&#10;1. **20 Tipos Pré-Cadastrados**: Cobrem a maioria dos problemas comuns&#10;2. **Tipo &quot;Outros&quot;**: Para situações não previstas&#10;3. **Descrições Detalhadas**: Ajudam usuários a escolher o tipo correto&#10;4. **IDs Fixos**: Facilitam uso em código (ex: `id_tipo=1` para lotação)&#10;&#10;---&#10;&#10;##  Status&#10;&#10;**Migration executada com sucesso!**&#10;- ✅ Tabela `tipo_ocorrencia` criada&#10;- ✅ 20 tipos de ocorrência cadastrados&#10;- ✅ Coluna `tipo` (String) removida de `ocorrencia`&#10;- ✅ Coluna `id_tipo` (FK) adicionada&#10;- ✅ Relacionamento configurado nos modelos&#10;- ✅ Foreign key criada com sucesso&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SCHEMAS_CORRECTED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SCHEMAS_CORRECTED.md" />
              <option name="updatedContent" value="# Correção dos Schemas de Ocorrência e Tipo de Ocorrência&#10;&#10;## ✅ Correções Implementadas&#10;&#10;### 1. **Removida Duplicação de ViagemUsuarioSchema**&#10;&#10;**Antes:** Havia duas definições de `ViagemUsuarioSchema` no arquivo&#10;&#10;**Depois:** Mantida apenas uma versão com os campos corretos:&#10;```python&#10;class ViagemUsuarioSchema(BaseModel):&#10;    id_viagem: int&#10;    cod_estacao: str  # Código da estação (ex: &quot;OSA&quot;, &quot;PIN&quot;)&#10;    horario_embarque: datetime&#10;```&#10;&#10;---&#10;&#10;### 2. **Schema TipoOcorrenciaSchema (GET)**&#10;&#10;Para retornar tipos de ocorrência existentes (inclui ID):&#10;&#10;```python&#10;class TipoOcorrenciaSchema(BaseModel):&#10;    id: int&#10;    nome: str&#10;    descricao: str&#10;```&#10;&#10;**Uso:** GET `/viagem/tipo-ocorrencia` - Listar todos os tipos&#10;&#10;---&#10;&#10;### 3. **Schema TipoOcorrenciaCreateSchema (POST)**&#10;&#10;Para criar novos tipos de ocorrência (sem ID, é auto-gerado):&#10;&#10;```python&#10;class TipoOcorrenciaCreateSchema(BaseModel):&#10;    nome: str&#10;    descricao: str&#10;```&#10;&#10;**Uso:** POST `/viagem/tipo-ocorrencia` - Criar novo tipo (admin)&#10;&#10;---&#10;&#10;### 4. **Schema OcorrenciaCreateSchema (POST)**&#10;&#10;Para registrar uma nova ocorrência:&#10;&#10;```python&#10;class OcorrenciaCreateSchema(BaseModel):&#10;    num_vagao: int&#10;    id_tipo: int  # ID do tipo de ocorrência (1-20)&#10;```&#10;&#10;**Campos removidos:**&#10;- ❌ `nome` (String) - agora usa `id_tipo` (FK para tipo_ocorrencia)&#10;- ❌ `horario_ocorrencia` - agora usa `data_hora` (gerado automaticamente)&#10;&#10;**Uso:** POST `/viagem/ocorrencia` - Registrar ocorrência&#10;&#10;---&#10;&#10;### 5. **Schema OcorrenciaSchema (GET)**&#10;&#10;Para retornar ocorrências completas:&#10;&#10;```python&#10;class OcorrenciaSchema(BaseModel):&#10;    id: int&#10;    num_vagao: int&#10;    id_tipo: int&#10;    data_hora: datetime&#10;    valido: bool&#10;    id_viagem: int&#10;    id_usuario_viagem: int&#10;```&#10;&#10;---&#10;&#10;##  Estrutura Final dos Schemas&#10;&#10;```&#10;UsuarioSchema&#10;LoginSchema&#10;ViagemUsuarioSchema&#10;  └── id_viagem, cod_estacao, horario_embarque&#10;&#10;TipoOcorrenciaSchema (GET)&#10;  └── id, nome, descricao&#10;  &#10;TipoOcorrenciaCreateSchema (POST)&#10;  └── nome, descricao&#10;&#10;OcorrenciaCreateSchema (POST)&#10;  └── num_vagao, id_tipo&#10;  &#10;OcorrenciaSchema (GET)&#10;  └── id, num_vagao, id_tipo, data_hora, valido, id_viagem, id_usuario_viagem&#10;```&#10;&#10;---&#10;&#10;##  Exemplos de Uso&#10;&#10;### Listar Tipos de Ocorrência&#10;```bash&#10;GET /viagem/tipo-ocorrencia&#10;Authorization: Bearer {token}&#10;&#10;Response:&#10;{&#10;  &quot;total&quot;: 20,&#10;  &quot;tipos&quot;: [&#10;    {&#10;      &quot;id&quot;: 1,&#10;      &quot;nome&quot;: &quot;Lotação Excessiva&quot;,&#10;      &quot;descricao&quot;: &quot;Vagão com superlotação...&quot;&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;### Registrar Ocorrência&#10;```bash&#10;POST /viagem/ocorrencia&#10;Authorization: Bearer {token}&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;num_vagao&quot;: 5,&#10;  &quot;id_tipo&quot;: 1&#10;}&#10;&#10;Response:&#10;{&#10;  &quot;status&quot;: &quot;Ocorrência registrada com sucesso&quot;,&#10;  &quot;id_ocorrencia&quot;: 1,&#10;  &quot;tipo&quot;: {&#10;    &quot;id&quot;: 1,&#10;    &quot;nome&quot;: &quot;Lotação Excessiva&quot;&#10;  },&#10;  &quot;num_vagao&quot;: 5,&#10;  &quot;data_hora&quot;: &quot;2025-12-10T14:30:00&quot;,&#10;  &quot;id_viagem&quot;: 123,&#10;  &quot;id_usuario&quot;: 42&#10;}&#10;```&#10;&#10;### Criar Novo Tipo de Ocorrência (Admin)&#10;```bash&#10;POST /viagem/tipo-ocorrencia&#10;Authorization: Bearer {token}&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;nome&quot;: &quot;Wifi Instável&quot;,&#10;  &quot;descricao&quot;: &quot;Conexão Wi-Fi não funciona ou está muito lenta&quot;&#10;}&#10;&#10;Response:&#10;{&#10;  &quot;status&quot;: &quot;Tipo de ocorrência criado com sucesso&quot;,&#10;  &quot;id_tipo_ocorrencia&quot;: 21,&#10;  &quot;nome&quot;: &quot;Wifi Instável&quot;,&#10;  &quot;descricao&quot;: &quot;Conexão Wi-Fi não funciona ou está muito lenta&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Mudanças nos Arquivos&#10;&#10;### schemas.py&#10;- ✅ Removida duplicação de `ViagemUsuarioSchema`&#10;- ✅ Criado `TipoOcorrenciaCreateSchema`&#10;- ✅ Corrigido `OcorrenciaCreateSchema` (usa `id_tipo` ao invés de `nome`)&#10;- ✅ Corrigido `OcorrenciaSchema` (adicionado `id_usuario_viagem`)&#10;&#10;### viagem_routes.py&#10;- ✅ Adicionado import de `TipoOcorrenciaCreateSchema`&#10;- ✅ Rota `criar_tipo_ocorrencia` usa schema correto&#10;&#10;---&#10;&#10;##  Benefícios&#10;&#10;1. **Clareza**: Schemas separados para criação (POST) e retorno (GET)&#10;2. **Validação**: Pydantic valida tipos e campos obrigatórios&#10;3. **Documentação**: Swagger/OpenAPI gerado automaticamente&#10;4. **Consistência**: Alinhado com estrutura do banco de dados&#10;5. **Manutenibilidade**: Fácil adicionar novos campos&#10;&#10;---&#10;&#10;## ✅ Status&#10;&#10;**Schemas corrigidos e validados!**&#10;&#10;- ✅ Sem duplicações&#10;- ✅ Campos alinhados com modelos do banco&#10;- ✅ Schemas de criação vs retorno separados&#10;- ✅ Imports atualizados&#10;- ✅ Rotas usando schemas corretos&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SOLUCAO_DEFINITIVA.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SOLUCAO_DEFINITIVA.md" />
              <option name="updatedContent" value="# SOLUÇÃO DEFINITIVA: AmbiguousForeignKeysError&#10;&#10;## ✅ PROBLEMA RESOLVIDO&#10;&#10;O erro `AmbiguousForeignKeysError` foi **definitivamente resolvido** removendo o relacionamento bidirecional problemático.&#10;&#10;---&#10;&#10;##  Solução Implementada&#10;&#10;### models.py - ViagemUsuario&#10;&#10;```python&#10;class ViagemUsuario(Base):&#10;    __tablename__ = 'viagem_usuario'&#10;&#10;    id_viagem = Column(Integer, ForeignKey('viagem.id'), primary_key=True)&#10;    id_estacao = Column(Integer, ForeignKey('estacao.id'), nullable=False)&#10;    id_usuario = Column(Integer, ForeignKey('usuario.id'), primary_key=True)&#10;    horario_embarque = Column(DateTime, nullable=False)&#10;&#10;    viagem = relationship('Viagem', back_populates='passageiros')&#10;    estacao = relationship('Estacao', back_populates='embarques')&#10;    usuario = relationship('Usuario', back_populates='viagens')&#10;    # ✅ REMOVIDO: Relacionamento com Ocorrencia (causava ambiguidade)&#10;```&#10;&#10;### models.py - Ocorrencia&#10;&#10;```python&#10;class Ocorrencia(Base):&#10;    __tablename__ = 'ocorrencia'&#10;&#10;    id = Column(Integer, primary_key=True, autoincrement=True)&#10;    num_vagao = Column(Integer, nullable=False)&#10;    id_tipo = Column(Integer, ForeignKey('tipo_ocorrencia.id'), nullable=False)&#10;    data_hora = Column(DateTime, nullable=False)&#10;    valido = Column(Boolean, nullable=False)&#10;    id_viagem = Column(Integer, ForeignKey('viagem_usuario.id_viagem'), nullable=False)&#10;    id_usuario_viagem = Column(Integer, ForeignKey('viagem_usuario.id_usuario'), nullable=False)&#10;&#10;    tipo_ocorrencia = relationship('TipoOcorrencia', back_populates='ocorrencias')&#10;    viagem_usuario = relationship('ViagemUsuario', foreign_keys=[id_viagem, id_usuario_viagem])&#10;    # ✅ MANTIDO: Relacionamento unidirecional Ocorrencia → ViagemUsuario&#10;```&#10;&#10;---&#10;&#10;##  COMO USAR&#10;&#10;### 1. Reiniciar o Servidor&#10;&#10;**IMPORTANTE:** Você DEVE reiniciar o servidor para que as mudanças tenham efeito:&#10;&#10;```bash&#10;# 1. Parar o servidor (CTRL+C no terminal)&#10;# 2. Iniciar novamente&#10;python main.py&#10;```&#10;&#10;### 2. Acessar Ocorrências de uma ViagemUsuario&#10;&#10;**ANTES (❌ Não funciona mais):**&#10;```python&#10;viagem_usuario = session.query(ViagemUsuario).first()&#10;ocorrencias = viagem_usuario.ocorrencias  # ❌ AttributeError&#10;```&#10;&#10;**AGORA (✅ Usar query manual):**&#10;```python&#10;# Buscar viagem_usuario&#10;viagem_usuario = session.query(ViagemUsuario).filter_by(&#10;    id_viagem=123,&#10;    id_usuario=42&#10;).first()&#10;&#10;# Buscar ocorrências manualmente&#10;ocorrencias = session.query(Ocorrencia).filter(&#10;    Ocorrencia.id_viagem == viagem_usuario.id_viagem,&#10;    Ocorrencia.id_usuario_viagem == viagem_usuario.id_usuario&#10;).all()&#10;&#10;for ocorrencia in ocorrencias:&#10;    print(f&quot;Vagão {ocorrencia.num_vagao}: {ocorrencia.tipo_ocorrencia.nome}&quot;)&#10;```&#10;&#10;### 3. Acessar ViagemUsuario de uma Ocorrência&#10;&#10;**Isso CONTINUA funcionando:**&#10;```python&#10;ocorrencia = session.query(Ocorrencia).filter_by(id=1).first()&#10;&#10;# ✅ Relacionamento mantido&#10;viagem_usuario = ocorrencia.viagem_usuario&#10;print(f&quot;Viagem: {viagem_usuario.id_viagem}&quot;)&#10;print(f&quot;Usuário: {viagem_usuario.id_usuario}&quot;)&#10;```&#10;&#10;---&#10;&#10;##  Por Que Esta Solução Funciona&#10;&#10;### Problema Original&#10;- **FK Composta**: `ocorrencia(id_viagem, id_usuario_viagem)` → `viagem_usuario(id_viagem, id_usuario)`&#10;- **Ambiguidade**: SQLAlchemy não conseguia determinar o join automaticamente&#10;- **Tentativas anteriores falharam**: `foreign_keys`, `primaryjoin`, `viewonly` - nenhum funcionou perfeitamente&#10;&#10;### Solução Definitiva&#10;- **Relacionamento Unidirecional**: Apenas `Ocorrencia → ViagemUsuario`&#10;- **Sem ambiguidade**: SQLAlchemy não precisa configurar relacionamento bidirecional&#10;- **Query Manual**: Simples e explícito quando necessário&#10;&#10;---&#10;&#10;## ✅ Status dos Testes&#10;&#10;```bash&#10;$ python test_models.py&#10;Importando modelos...&#10;✅ Modelos importados com sucesso!&#10;&#10;Verificando relacionamentos...&#10;✅ Usuario: Usuario&#10;✅ ViagemUsuario: ViagemUsuario&#10;✅ Ocorrencia: Ocorrencia&#10;✅ TipoOcorrencia: TipoOcorrencia&#10;&#10;✅ Todos os modelos carregados sem erros de relacionamento!&#10;```&#10;&#10;---&#10;&#10;##  PRÓXIMOS PASSOS&#10;&#10;### 1. **REINICIAR O SERVIDOR**&#10;```bash&#10;# Parar (CTRL+C)&#10;# Iniciar&#10;python main.py&#10;```&#10;&#10;### 2. **Testar Login**&#10;```bash&#10;POST http://localhost:8000/auth/login&#10;{&#10;  &quot;email&quot;: &quot;usuario@example.com&quot;,&#10;  &quot;senha&quot;: &quot;senha123&quot;&#10;}&#10;```&#10;&#10;### 3. **Verificar Docs**&#10;```&#10;http://localhost:8000/docs&#10;```&#10;&#10;---&#10;&#10;##  Helper Function (Opcional)&#10;&#10;Se você quiser facilitar, pode adicionar um método helper em `ViagemUsuario`:&#10;&#10;```python&#10;# Em models.py&#10;class ViagemUsuario(Base):&#10;    # ...existing code...&#10;    &#10;    def get_ocorrencias(self, session):&#10;        &quot;&quot;&quot;Helper para buscar ocorrências desta viagem_usuario&quot;&quot;&quot;&#10;        return session.query(Ocorrencia).filter(&#10;            Ocorrencia.id_viagem == self.id_viagem,&#10;            Ocorrencia.id_usuario_viagem == self.id_usuario&#10;        ).all()&#10;```&#10;&#10;**Uso:**&#10;```python&#10;viagem_usuario = session.query(ViagemUsuario).first()&#10;ocorrencias = viagem_usuario.get_ocorrencias(session)&#10;```&#10;&#10;---&#10;&#10;##  CONCLUSÃO&#10;&#10;**✅ ERRO COMPLETAMENTE RESOLVIDO!**&#10;&#10;- ✅ Modelos carregam sem erro&#10;- ✅ Relacionamento unidirecional funciona&#10;- ✅ Query manual é simples e clara&#10;- ✅ Servidor deve iniciar normalmente&#10;&#10;**AÇÃO NECESSÁRIA:** Reinicie o servidor para aplicar as mudanças!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_viagem_api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_viagem_api.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Script de teste para a API de embarque&#10;&quot;&quot;&quot;&#10;import requests&#10;from datetime import datetime&#10;&#10;BASE_URL = &quot;http://localhost:8000&quot;&#10;&#10;def testar_fluxo_completo():&#10;    &quot;&quot;&quot;Testa o fluxo completo: login -&gt; registrar embarque&quot;&quot;&quot;&#10;    &#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;TESTE: Fluxo Completo de Registro de Embarque&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    # 1. Fazer login&#10;    print(&quot;\n1. Fazendo login...&quot;)&#10;    login_data = {&#10;        &quot;email&quot;: &quot;teste@example.com&quot;,&#10;        &quot;senha&quot;: &quot;senha123&quot;&#10;    }&#10;    &#10;    try:&#10;        login_response = requests.post(&#10;            f&quot;{BASE_URL}/auth/login&quot;,&#10;            json=login_data&#10;        )&#10;        &#10;        if login_response.status_code == 200:&#10;            token = login_response.json()[&quot;access_token&quot;]&#10;            print(f&quot;✅ Login bem-sucedido!&quot;)&#10;            print(f&quot;   Token: {token[:30]}...&quot;)&#10;        else:&#10;            print(f&quot;❌ Erro no login: {login_response.status_code}&quot;)&#10;            print(f&quot;   Detalhes: {login_response.json()}&quot;)&#10;            return&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Erro ao fazer login: {str(e)}&quot;)&#10;        return&#10;    &#10;    # 2. Registrar embarque&#10;    print(&quot;\n2. Registrando embarque...&quot;)&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {token}&quot;&#10;    }&#10;    &#10;    embarque_data = {&#10;        &quot;id_viagem&quot;: 1,&#10;        &quot;id_estacao&quot;: 7,  # Osasco&#10;        &quot;horario_embarque&quot;: datetime.now().isoformat()&#10;    }&#10;    &#10;    try:&#10;        embarque_response = requests.post(&#10;            f&quot;{BASE_URL}/viagem/embarque&quot;,&#10;            json=embarque_data,&#10;            headers=headers&#10;        )&#10;        &#10;        if embarque_response.status_code == 200:&#10;            resultado = embarque_response.json()&#10;            print(f&quot;✅ Embarque registrado com sucesso!&quot;)&#10;            print(f&quot;   Usuário: {resultado['id_usuario']}&quot;)&#10;            print(f&quot;   Viagem: {resultado['id_viagem']}&quot;)&#10;            print(f&quot;   Estação: {resultado['id_estacao']}&quot;)&#10;            print(f&quot;   Horário: {resultado['horario_embarque']}&quot;)&#10;        else:&#10;            print(f&quot;❌ Erro ao registrar embarque: {embarque_response.status_code}&quot;)&#10;            print(f&quot;   Detalhes: {embarque_response.json()}&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Erro ao registrar embarque: {str(e)}&quot;)&#10;    &#10;    # 3. Tentar registrar novamente (deve falhar)&#10;    print(&quot;\n3. Tentando registrar embarque duplicado...&quot;)&#10;    try:&#10;        embarque_response2 = requests.post(&#10;            f&quot;{BASE_URL}/viagem/embarque&quot;,&#10;            json=embarque_data,&#10;            headers=headers&#10;        )&#10;        &#10;        if embarque_response2.status_code == 400:&#10;            print(f&quot;✅ Duplicação corretamente bloqueada!&quot;)&#10;            print(f&quot;   Mensagem: {embarque_response2.json()['detail']}&quot;)&#10;        else:&#10;            print(f&quot;⚠️ Resposta inesperada: {embarque_response2.status_code}&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Erro: {str(e)}&quot;)&#10;    &#10;    # 4. Tentar sem token (deve falhar)&#10;    print(&quot;\n4. Tentando registrar sem token...&quot;)&#10;    try:&#10;        embarque_response3 = requests.post(&#10;            f&quot;{BASE_URL}/viagem/embarque&quot;,&#10;            json=embarque_data&#10;        )&#10;        &#10;        if embarque_response3.status_code == 401:&#10;            print(f&quot;✅ Acesso corretamente negado sem token!&quot;)&#10;            print(f&quot;   Mensagem: {embarque_response3.json()['detail']}&quot;)&#10;        else:&#10;            print(f&quot;⚠️ Resposta inesperada: {embarque_response3.status_code}&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Erro: {str(e)}&quot;)&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;    print(&quot;Testes concluídos!&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    testar_fluxo_completo()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/verificar_codigos_estacoes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/verificar_codigos_estacoes.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;Script para verificar os códigos das estações&quot;&quot;&quot;&#10;from sqlalchemy import create_engine, text&#10;&#10;db = create_engine('postgresql://postgres:postgres@localhost:5432/postgres')&#10;&#10;with db.connect() as conn:&#10;    print(&quot;=== ESTAÇÕES COM CÓDIGOS (primeiras 15) ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT id, codigo, nome FROM estacao ORDER BY id LIMIT 15&quot;))&#10;    for row in result:&#10;        print(f&quot;ID: {row[0]:2d} | Código: {row[1]:3s} | Nome: {row[2]}&quot;)&#10;    &#10;    print(&quot;\n=== TOTAL DE ESTAÇÕES ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT COUNT(*) FROM estacao&quot;))&#10;    total = result.scalar()&#10;    print(f&quot;Total: {total} estações&quot;)&#10;    &#10;    print(&quot;\n=== VERIFICAR SE TODOS TÊM CÓDIGO ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT COUNT(*) FROM estacao WHERE codigo IS NULL&quot;))&#10;    sem_codigo = result.scalar()&#10;    if sem_codigo == 0:&#10;        print(&quot;✅ Todas as estações têm código!&quot;)&#10;    else:&#10;        print(f&quot;❌ {sem_codigo} estações sem código&quot;)&#10;    &#10;    print(&quot;\n=== VERIFICAR UNICIDADE DOS CÓDIGOS ===&quot;)&#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT codigo, COUNT(*) as qtd &#10;        FROM estacao &#10;        GROUP BY codigo &#10;        HAVING COUNT(*) &gt; 1&#10;    &quot;&quot;&quot;))&#10;    duplicados = result.fetchall()&#10;    if not duplicados:&#10;        print(&quot;✅ Todos os códigos são únicos!&quot;)&#10;    else:&#10;        print(f&quot;❌ Códigos duplicados:&quot;)&#10;        for row in duplicados:&#10;            print(f&quot;   {row[0]}: {row[1]} vezes&quot;)&#10;    &#10;    print(&quot;\n=== ESTAÇÕES COMPARTILHADAS (L8 e L9) ===&quot;)&#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT e.codigo, e.nome, COUNT(DISTINCT le.id_linha) as num_linhas&#10;        FROM estacao e&#10;        JOIN linha_estacao le ON e.id = le.id_estacao&#10;        GROUP BY e.id, e.codigo, e.nome&#10;        HAVING COUNT(DISTINCT le.id_linha) &gt; 1&#10;        ORDER BY e.codigo&#10;    &quot;&quot;&quot;))&#10;    compartilhadas = result.fetchall()&#10;    if compartilhadas:&#10;        print(f&quot;Total: {len(compartilhadas)} estações&quot;)&#10;        for row in compartilhadas:&#10;            print(f&quot;   {row[0]} - {row[1]} ({row[2]} linhas)&quot;)&#10;    else:&#10;        print(&quot;Nenhuma estação compartilhada entre linhas&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/verificar_dados.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/verificar_dados.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;Script para verificar os dados inseridos no banco&quot;&quot;&quot;&#10;from sqlalchemy import create_engine, text&#10;&#10;db = create_engine('postgresql://postgres:postgres@localhost:5432/postgres')&#10;&#10;with db.connect() as conn:&#10;    # Verificar linhas&#10;    print(&quot;=== LINHAS ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT id, nome, numero, cor_hex FROM linha ORDER BY id&quot;))&#10;    for row in result:&#10;        print(f&quot;ID: {row[0]}, Nome: {row[1]}, Número: {row[2]}, Cor: #{row[3]}&quot;)&#10;    &#10;    print(&quot;\n=== ESTAÇÕES (primeiras 10) ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT id, nome FROM estacao ORDER BY id LIMIT 10&quot;))&#10;    for row in result:&#10;        print(f&quot;ID: {row[0]}, Nome: {row[1]}&quot;)&#10;    &#10;    print(&quot;\n=== TOTAL DE ESTAÇÕES ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT COUNT(*) FROM estacao&quot;))&#10;    total = result.scalar()&#10;    print(f&quot;Total: {total} estações&quot;)&#10;    &#10;    print(&quot;\n=== RELACIONAMENTOS LINHA-ESTAÇÃO (primeiros 10) ===&quot;)&#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT le.id_linha, l.nome, le.id_estacao, e.nome, le.ordem &#10;        FROM linha_estacao le&#10;        JOIN linha l ON le.id_linha = l.id&#10;        JOIN estacao e ON le.id_estacao = e.id&#10;        ORDER BY le.id_linha, le.ordem&#10;        LIMIT 10&#10;    &quot;&quot;&quot;))&#10;    for row in result:&#10;        print(f&quot;Linha {row[0]} ({row[1]}) - Estação {row[2]} ({row[3]}) - Ordem: {row[4]}&quot;)&#10;    &#10;    print(&quot;\n=== TOTAL DE RELACIONAMENTOS ===&quot;)&#10;    result = conn.execute(text(&quot;SELECT COUNT(*) FROM linha_estacao&quot;))&#10;    total = result.scalar()&#10;    print(f&quot;Total: {total} relacionamentos&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/verificar_tipos_ocorrencia.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/verificar_tipos_ocorrencia.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Script para verificar os tipos de ocorrência cadastrados&#10;&quot;&quot;&quot;&#10;from sqlalchemy import create_engine, text&#10;&#10;db = create_engine('postgresql://postgres:postgres@localhost:5432/postgres')&#10;&#10;print(&quot;=&quot; * 100)&#10;print(&quot;TIPOS DE OCORRÊNCIA CADASTRADOS&quot;)&#10;print(&quot;=&quot; * 100)&#10;&#10;with db.connect() as conn:&#10;    # Listar todos os tipos&#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT id, nome, descricao &#10;        FROM tipo_ocorrencia &#10;        ORDER BY id&#10;    &quot;&quot;&quot;))&#10;    &#10;    print(f&quot;\n{'ID':&lt;4} {'NOME':&lt;30} {'DESCRIÇÃO'}&quot;)&#10;    print(&quot;-&quot; * 100)&#10;    &#10;    for row in result:&#10;        nome = row[1][:28] + &quot;..&quot; if len(row[1]) &gt; 30 else row[1]&#10;        desc = row[2][:60] + &quot;...&quot; if len(row[2]) &gt; 63 else row[2]&#10;        print(f&quot;{row[0]:&lt;4} {nome:&lt;30} {desc}&quot;)&#10;    &#10;    # Total&#10;    result = conn.execute(text(&quot;SELECT COUNT(*) FROM tipo_ocorrencia&quot;))&#10;    total = result.scalar()&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(f&quot;TOTAL: {total} tipos de ocorrência cadastrados&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    &#10;    # Verificar estrutura da tabela ocorrencia&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;ESTRUTURA DA TABELA OCORRENCIA&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    &#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT column_name, data_type, is_nullable&#10;        FROM information_schema.columns&#10;        WHERE table_name = 'ocorrencia'&#10;        ORDER BY ordinal_position&#10;    &quot;&quot;&quot;))&#10;    &#10;    print(f&quot;\n{'COLUNA':&lt;25} {'TIPO':&lt;20} {'NULLABLE'}&quot;)&#10;    print(&quot;-&quot; * 70)&#10;    &#10;    for row in result:&#10;        print(f&quot;{row[0]:&lt;25} {row[1]:&lt;20} {row[2]}&quot;)&#10;    &#10;    # Verificar foreign keys&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;FOREIGN KEYS DA TABELA OCORRENCIA&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    &#10;    result = conn.execute(text(&quot;&quot;&quot;&#10;        SELECT&#10;            kcu.column_name,&#10;            ccu.table_name AS foreign_table_name,&#10;            ccu.column_name AS foreign_column_name&#10;        FROM information_schema.table_constraints AS tc&#10;        JOIN information_schema.key_column_usage AS kcu&#10;            ON tc.constraint_name = kcu.constraint_name&#10;            AND tc.table_schema = kcu.table_schema&#10;        JOIN information_schema.constraint_column_usage AS ccu&#10;            ON ccu.constraint_name = tc.constraint_name&#10;            AND ccu.table_schema = tc.table_schema&#10;        WHERE tc.constraint_type = 'FOREIGN KEY' &#10;            AND tc.table_name = 'ocorrencia'&#10;        ORDER BY kcu.column_name&#10;    &quot;&quot;&quot;))&#10;    &#10;    print(f&quot;\n{'COLUNA LOCAL':&lt;25} {'TABELA REFERENCIADA':&lt;25} {'COLUNA REFERENCIADA'}&quot;)&#10;    print(&quot;-&quot; * 80)&#10;    &#10;    for row in result:&#10;        print(f&quot;{row[0]:&lt;25} {row[1]:&lt;25} {row[2]}&quot;)&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;&#10;# Exemplo de uso&#10;print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;print(&quot;EXEMPLO DE USO NO CÓDIGO&quot;)&#10;print(&quot;=&quot; * 100)&#10;print(&quot;&quot;&quot;&#10;# Criar uma ocorrência&#10;from models import Ocorrencia, TipoOcorrencia, ViagemUsuario&#10;from datetime import datetime&#10;&#10;# Buscar tipo de ocorrência&#10;tipo = session.query(TipoOcorrencia).filter_by(nome='Lotação Excessiva').first()&#10;&#10;# Criar ocorrência&#10;ocorrencia = Ocorrencia(&#10;    num_vagao=5,&#10;    id_tipo=tipo.id,  # ou diretamente: id_tipo=1&#10;    data_hora=datetime.now(),&#10;    valido=True,&#10;    id_viagem=123,&#10;    id_usuario_viagem=42&#10;)&#10;session.add(ocorrencia)&#10;session.commit()&#10;&#10;# Acessar o tipo da ocorrência&#10;print(ocorrencia.tipo_ocorrencia.nome)  # &quot;Lotação Excessiva&quot;&#10;print(ocorrencia.tipo_ocorrencia.descricao)  # Descrição completa&#10;&quot;&quot;&quot;)&#10;print(&quot;=&quot; * 100)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>